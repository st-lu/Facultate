#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <queue>
using namespace std;
ifstream fin("CFG.in");

string word;
int noOfTerminals, noOfNonterminals, noOfProductions;;
vector<char> nonterminals;
vector<char> terminals;
map<char, vector<string> > productions; // lambda marked with '.'
char start;

void readGrammar() {
    fin >> noOfTerminals;
    for (int i = 0; i < noOfTerminals; i++) {
        char terminal;
        fin >> terminal;
        terminals.push_back(terminal);
    }

    fin >> noOfNonterminals;
    for (int i = 0; i < noOfNonterminals; i++) {
        char nonterminal;
        fin >> nonterminal;
        nonterminals.push_back(nonterminal);
    }

    fin >> noOfProductions;
    for (int i = 0; i < noOfProductions; i++) {
        char leftMember;
        string rightMember;
        fin >> leftMember >> rightMember;
        productions[leftMember].push_back(rightMember);
    }

    fin >> start;
}

// this function searches for a nonterminal(NT) in the given production
// it returns the position of the NT or -1 if no NT is found
int findNonterminal(string production) {
    for (int i = 0; i < production.size(); i++) {
        for(auto nonterminal : nonterminals){
            if(production[i] == nonterminal)
                return i;
        }
    }
    return -1;
}

//this function checks if the passed word can be generated by the input CIG
bool isGenerated(string &word) {
    queue<string> generatedWords;

    // add all the productions that can be obtained from the start nonterminal
    // to the vector of generated words
    for (auto &production : productions[start]) {
        generatedWords.push(production);

        // if there is a production made up of terminals that match the passed word
        // we stop the search
        if(word == production)
            return true;
    }

    // while there are productions to be tested
    while (!generatedWords.empty()) {
        string currentWord = generatedWords.front();
        generatedWords.pop();

        // searches for a nonterminal in the current word
        int nonTerminalPosition = findNonterminal(currentWord);

        if (nonTerminalPosition >= 0) {
            // if a nonterminal was found, we replace it with each of its productions
            // likeso : newWord = currentWord[0:NTPosition] + NTProduction + currentWord[NTPosition+1:cW.size()]
            char nonterminal = currentWord[nonTerminalPosition];
            for (auto &production : productions[nonterminal]) {
                string newWord;
                newWord.append(currentWord.begin(), currentWord.begin() + nonTerminalPosition);
                if (production != ".")
                    newWord.append(production);
                newWord.append(currentWord.begin() + nonTerminalPosition + 1, currentWord.end());

                // we only add words to the queue when
                // a newly generated word is >= in length compared to the initial word that was to be checked
                if (newWord.size() <= word.size())
                    generatedWords.push(newWord);
                if (newWord == word)
                    return true;
            }
        }
    }

    //if all possible candidate words have been generated and none match the passed word
    //than the passed word cannot be generated by the input CFG
    return false;
}

int main() {
    cin >> word;
    readGrammar();

    if (isGenerated(word)) {
        cout << "cuvantul poate fi generat de gramatica";
    } else {
        cout << "cuvantul nu poate fi generat de gramatica";
    }

    return 0;
}